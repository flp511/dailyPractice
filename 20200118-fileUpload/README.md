# 断点续传
* https://juejin.im/post/5dff8a26e51d4558105420ed

* 大文件上传
使用 Blob.prototype.slice 将文件切片前端上传大文件时使用 Blob.prototype.slice 将文件切片
服务端接收切片并存储，收到合并请求后使用 fs.appendFileSync 对多个切片进行合并       
另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序

* 切片记录顺序
使用 spark-md5 根据文件内容算出文件 hash 通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）
通过 XMLHttpRequest 的 abort 方法暂停切片的上传
上传前服务端返回已经上传的切片名，前端跳过这些切片的上传

* 优化
切片功能，放到 webworker 执行，通过 postMessage 向主线程
用http2
切片个数为切片的倍数
多用几个域名增加浏览器请求并发量

根据文件内容来生成 hash 的插件，知道git也是这样吧，不知是不是用的这个 spark-md5

* 文件秒传
即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功
秒传其实就是给用户看的，实质上根本没有上传
服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可

* 断点 + 续传，也就是 暂停 + 上传
1、当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果
2、点击上传时，检查是否需要上传和已上传的切片，
点击暂停后的恢复上传，返回已上传的切片
3、当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退 解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条
if (now > this.fakeUploadPercentage) this.fakeUploadPercentage = now; 