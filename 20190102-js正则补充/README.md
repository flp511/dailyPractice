# 资料
* http://www.cnblogs.com/dolphinX/p/3486214.html

# 定义

* 构造函数：`new RegExp('<%[^%>]+%>','g')`
* 字面量：`/<%[^%>]%>/g`
    * g： global，全文搜索，默认搜索到第一个结果接停止
    * i： ingore case，忽略大小写，默认大小写敏感
    * m： multiple lines，多行搜索（更改^ 和$的含义，使它们分别在任意一行对待行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配）
* 返回的结果，默认只认第一次匹配的，加上 `g` 才得匹配全部

# 元字符

* 元字符：( [ { \ ^ $ | ) ? * + .

# 类

* 可以使用元字符[]来构建一个简单的类，所谓类是指，符合某些特征的对象，是一个泛指，而不是特指某个字符了
* 我们可以使用表达式 [abc] 把字符a或b或c归为一类，表达式可以匹配这类的字符
* 还可以使用元字符^创建反向类，反向类的意思是不属于XXX类的内容
    * 表达式 [^abc] 表示不是字符a或b或c的内容
* 【类只匹配一个字符】，如：[abc]只匹配a或者b或者c

# 范围类

* [0-9]
* [a-z]
* [A-Z]
* [a-zA-Z]


# 预定义特殊字符

| 字符 | 含义 |
| :--- | :--- |
| \t | 水平制表符(tab) |
| \v | 垂直制表符 |
| \r | 回车符 |
| \n | 换行符(回车) |
| \f | 换页符 |
| \0 | 空字符 |

# 预定义类
| 字符	    | 等价类	          |     含义                            |
| :---	    | :---	             |     :---                           |
| .	        | [^\n\r]	          |  【除了回车符和换行符之外的所有字符】   |
| \d	    | [0-9]	              | 数字字符                            |
| \D	    | [^0-9]	          |    非数字字符                       |
| \s	    | [ \t\n\x0B\f\r]	  |    空白符                           |
| \S	    | [^ \t\n\x0B\f\r]    |  非空白符                           |
| \w	    | [a-zA-Z_0-9]	      | 单词字符（字母、数字、下划线）         |
| \W	    | [^a-zA-Z_0-9]	      | 非单词字符                           |

# 边界

|字符 | 含义 |
|:---| :--- |
|^   |以xx开头|
|$   |以xx结尾|
|\b  |单词边界，指[a-zA-Z_0-9]之外的字符|
|\B  |非单词边界|

# 量词

|  字符	 |   含义 |
|:---    | :---  |
|?	     |   出现零次或一次（最多出现一次）|
|+	     |   出现一次或多次（至少出现一次）|
|*	     |   出现零次或多次（任意次）|
|{n}	 |       出现n次|
|{n,m}	 |   出现n到m次|
|{n,}	 |   至少出现n次|

# 贪婪模式与非贪婪模式

* 贪婪模式：量词在默认下是尽可能多的匹配
    ```js
    '123456789'.match(/\d{3,5}/g); // ["12345", "6789"] 
    ```
* 非贪婪模式：尽可能少的匹配，也就是说一旦成功匹配不再继续尝试，做法很简单，在量词后加上 ?
    ```js
    '123456789'.match(/\d{3,5}?/g); // ["123", "456", "789"]
    ```

# 分组

* 有时候我们希望使用量词的时候匹配多个字符，如 `abcabcabc`这样的的字母组合
    ```js
    /(abc){3,}/
    ```
* 多种组合之间用`|`隔开
    ```js
    /(FLP|LYF){2}/
    ```
* 使用分组的正则表达式会把匹配项也放到分组中，默认就是按数字编号分发的，各异根据编号获得捕获的分组内容
    * 如果有分组嵌套的情况，外面的组的编号靠前
    ```js
    'FLP&&&LYF'.replace(/(FLP).*(LYF)/g, '【"$1"】【"$2"】'); // "【"FLP"】【"LYF"】"
    'FLP&&&LYF'.replace(/((FLP).*(LYF))/g, '【"$1"】【"$2"】【"$3"】'); // "【"FLPdsfLYF"】【"FLP"】【"LYF"】"
    ```

* 有时候我们不希望捕获某些分组，只需要在分组内加上 ?: 就可以了，着并不意味着该分组内容不属于正则表达式，只是不会给这个分组加编号了而已
    ```js
    'FLP&&&LYF'.replace(/(?:FLP).*(LYF)/g, '【"$1"】【"$2"】'); // "【"LYF"】【"$2"】" 对应的第二个就被当成了字符串了，因为没有"$2"
    ```

# RegExp实例对象有五个属性

1. global：是否全局搜索，默认是false
2. ignoreCase：是否大小写敏感，默认是false
3. multiline：多行搜索，默认值是false
4. lastIndex：是当前表达式模式首次匹配内容中最后一个字符的下一个位置，每次正则表达式成功匹配时，5. lastIndex属性值都会随之改变。
6. source：正则表达式的文本字符串

# RegExp原型方法

1. compile：将正则表达式编译为内部格式从而使执行更快的
2. test：方法用于测试字符串参数中是否存正则表达式模式，如果存在则返回true，否则返回false
3. exec：找到了匹配的文本，则返回一个结果数组。否则，返回 null。
    * 除了数组元素和 length 属性之外，还有：index、input、groups
    * index 属性声明的是匹配文本的第一个字符的位置
    * input 属性则存放的是被检索的字符串 string

* 调用非全局的 RegExp对象的 exec() 时，返回数组的第 0 个元素是与正则表达式相匹配的文本（这个是由文本内容决定的，不是由正则内容决定的），第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExp对象的第 2 个子表达式相匹配的文本（如果有的话），以此类推。

# 字符串方法

* strObj.search(RegObj)
    * search：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。
* match：找到一个或多个与 regexp 匹配的文本。但是否具有标志 g对结果影响很大。
    * 非全局匹配
        * 该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。
        * 除了这些常规的数组元素之外，返回的数组还含有两个对象属性。
        * index 属性声明的是匹配文本的起始字符在 stringObject 中的位置。(第一次匹配到值所在的索引)
        * input 属性声明的是对 stringObject 的引用（就是被检索的那个串，值和第0个元素看起来一样的）
    * 全局匹配返回的是匹配到的所有文本，【用match非全局匹配结果同exec方法一样】
* strObj.replace(regObj,replaceStr)
    * 如果replace方法的第一个参数传入的是带分组的正则表达式，我们在第二个参数中可以使用$1...$9来获取相应分组内容
        * 比如希望把字符串 1<%2%>34<%567%>89 的<%x%>换为$#x#$，我们可以这样
        ```js
        '1<%2%>34<%567%>89'.replace(/<%(\d+)%>/g,'@#$1#@'); // "1@#2#@34@#567#@89"
        ```
    * 第二个参数传入一个function，这个function会在每次匹配替换的时候调用，算是个每次替换的回调函数，我们使用了回调函数的第一个参数，也就是匹配内容，其实回调函数一共有四个参数

    1. 第一个参数很简单，是匹配字符串
    2. 第二个参数是正则表达式分组内容，没有分组则没有该参数(就是小括号匹配到的值)
    3. 第三个参数是匹配项在字符串中的index
    4. 第四个参数则是原字符串
    * 【`$&` 代表匹配到的值，`$^`代表匹配文本的左侧内容，`$'`代表匹配文本的右侧内容，`$n`为正则分组匹配的第n组那个匹配值】

* strObj.split(regObj)
    ```js
    'a1b2c3d'.split(/\d/); //["a", "b", "c", "d"]
    ```
* 将第一个div的内容首字母大写
    ```js
    'div>abcd'.replace(/(div\>)([a-z])([a-z]*)/, (...arg) => {
        console.log(arg);
        return arg[1] + arg[2].toUpperCase() + arg[3];
    });
    ```

# 补充

* 回车符（'\r'），此“回车”（回车符）非彼“回车”（回车键）。
```
回车（'\r'）效果是输出回到本行行首，结果可能会将这一行之前的输出覆盖掉。例如执行：
puts("hello world!\rxxx");
    在终端输出的是：

    xxxlo world!
```

* 垂直制表符（'\v'） 垂直制表符不常用
```
且开始的列数为“\v”前一个字符所在列后面一列。例如： puts("01\v2345");
在终端输出为:

01
   2345
```

# 重点

* 分组、类的区别
* 正则实例的方法、可使用正则的字符串方法
* 【用match非全局匹配结果同exec方法一样】，全局匹配返回的是匹配到的所有文本
